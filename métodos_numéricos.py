# -*- coding: utf-8 -*-
"""Métodos Numéricos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RndHC8CZbxmgWCTisTyDTzzNwNB2EuZ3

Busquedas Incrementales (Input: f(x) = 0 ; x0 ; deltaX
*texto en cursiva*)
"""

import sympy as sym
x = sym.Symbol('x')

def busquedasIncrementales (f, x0, deltax, numIteracion):
  if f.subs(x, x0) == 0:
    return (str(x0) + " Es una raíz de " + str(f))
  else: 
    xn = x0 + deltax
    iter = 0
  while (numIteracion > iter and (f.subs(x,x0) * f.subs(x,xn)) > 0):
    x0 = xn
    xn = x0 + deltax
    iter += 1
  if f.subs(x,xn) == 0:
    return (str(xn) + " Es una raíz de " + str(f))
  elif (f.subs(x,x0) * f.subs(x,xn)) < 0:
    return ("Existe una raíz de " + str(f) + " entre " + str(x0) + " y " + str(xn))
  else:
    return ("No se han encontrado raices")

busquedasIncrementales(x**3 - 7.51*x**2 + 18.4239*x - 14.8331, 0, 0.5, 1000)

"""Método de la bisección (Tiene que haber una raíz en el intervalo)

Input (xi, xf, f(x), tolerancia, num iteraciones)
"""

import sympy as sym
x = sym.Symbol('x')

def biseccion(f,xi, xf, tol, numIter):
  if (f.subs(x,xi) * f.subs(x,xf) == 0):
    if (f.subs(x,xi) == 0):
      return("Hay una raíz de " + str(f) + " en " + str(xi))
    if (f.subs(x,xf) == 0):
      return("Hay una raíz de " + str(f) + " en " + str(xf))
  elif (f.subs(x,xi) * f.subs(x,xf) > 0):
    return("No se encuentran raices de " + str(f) )
  else: 
    xm = (xi + xf)/2
    numIteracion = 0
    error = abs(xi-xm)
    while (error>tol and numIteracion<numIter and f.subs(x,xm) != 0):
      if (f.subs(x,xi) * f.subs(x,xm) < 0):
        xf = xm
      else: 
        xi = xm
      xm = (xi + xf) / 2
      error = abs(xm - xi)
      numIteracion += 1
    if (f.subs(x,xm) == 0):
      return("Se halló una raíz en " + str(xm) )
    elif error < tol: 
      return( str(xm) + " es raíz, con una toleracia de " + str(tol))
    else:
      return("No se halló una solución")

biseccion(x**3 + 2*x**2 - x -1 ,-3, -1  , 0.01, 50)

"""Método de Regla falsa (Intervalo con una raíz)
Input (xi, xf, f(x), tolerancia, num iteraciones)
"""

import sympy as sym
x = sym.Symbol('x')

def reglaFalsa (f,xi, xf, tol, numIter):
  if (f.subs(x,xi) * f.subs(x,xf) == 0):
    if (f.subs(x,xi) == 0):
      return("Hay una raíz de " + str(f) + " en " + str(xi))
    if (f.subs(x,xf) == 0):
      return("Hay una raíz de " + str(f) + " en " + str(xf))
  elif (f.subs(x,xi) * f.subs(x,xf) > 0):
    return("No se encuentran raices de " + str(f) )
  else: 
    xm = xf -((f.subs(x,xf)*(xi-xf))/(f.subs(x,xi)-f.subs(x,xf)))
    xm = float(xm)
    numIteracion = 0
    error = abs(xi-xm)
    while (error>tol and numIteracion<numIter and f.subs(x,xm) != 0):
      if (f.subs(x,xi) * f.subs(x,xm) < 0):
        xf = xm
      else: 
        xi = xm
      xm = xf -((f.subs(x,xf)*(xi-xf))/(f.subs(x,xi)-f.subs(x,xf)))
      xm = float(xm)
      error = abs(xm - xf)
      numIteracion += 1
    if (f.subs(x,xm) == 0):
      return("Se halló una raíz en " + str(xm) )
    elif error < tol: 
      return( str(xm) + " Es raíz con una toleracia de " + str(tol))
    else:
      return("No se halló una solución")

reglaFalsa (x**3 + 2*x**2 - x -1,-3, -1 , 0.01, 50)



"""Método de punto fijo (Método abierto)
Input (g(x) = x, x0, numIterations, tol

"""

import sympy as sym
from math import e
from math import sqrt
x = sym.Symbol('x')

def puntoFijo(f,x0,numIter, tol):
  g= -(f-x)
  iter = 0
  error = tol + 1
  while (iter < numIter and error > tol):
    xn = float(g.subs(x,x0))
    error = abs(xn - x0)
    iter += 1
    x0 = xn
  if error <= tol:
    return(str(xn) + " es raíz con tolerancia de " + str(tol))
  else:
    return("El método no converge")
f = x**3 + 2*x**2 - x -1
puntoFijo(f, 1, 100, 0.00001)

"""Método de secante"""

import sympy as sym
x = sym.Symbol('x')

def metodoSecante(f,x0,x1,numIter,tol):
  iter = 0
  while iter <= numIter:
    newX1 = float(x1 - (f.subs(x, x1)*((x1 - x0) / (f.subs(x, x1) - f.subs(x, x0)))))
    if f.subs(x, x0) == 0:
      return(str(x0) + " Es una raíz de " + str(f))
    elif abs(newX1 - x1) <= tol:
      return(str(newX1) + " es raíz con tolerancia " + str(tol) + " con numero de iteraciones " + str(iter) )
    elif iter > numIter:
      return("El metodo no converge en estas iteraciones " + str(iter))
    else:
      iter += 1
      x0 = x1
      x1 = newX1
f = x - (3*x/(x**2 + 9)**(1/2)) -7/40
metodoSecante(f, 1, 2, 1000, 0.00005)

"""Método de Newton"""

import sympy as sym
import math
x = sym.Symbol('x')
def Newton (f, df, x0, numIter, tol):
  cont = 0
  error = tol + 1
  while (cont < numIter and error > tol):
    xn = x0 - float(f.subs(x, x0))/float(df.subs(x, x0))
    error = abs(xn - x0)
    cont += 1
    x0 = xn
  if error <= tol:
    return(str(xn) + " es raíz con tolerancia " + str(tol)+ " y el algorítmo paró en la iteración: " + str(cont))
  else:
    return("El método no converge")

f = x - (3*x/(x**2 + 9)**(1/2))- 7/40
df = sym.diff(f, x)
Newton(f, df, 1, 10000, 0.00005)

"""Raíces multiples"""

import sympy as sym
import math
x = sym.Symbol('x')

def RaicesMultiples (f, df, dff, x0, numIter, tol):
  iter = 0
  error = tol + 1
  while (iter < numIter and error > tol):
    xn = x0 - (float(f.subs(x, x0)*df.subs(x,x0))/float(df.subs(x, x0)**2-(f.subs(x, x0)*dff.subs(x,x0))))
    error = abs(xn - x0)
    iter += 1
    x0 = xn
  if error <= tol:
    return(str(xn) + " es raíz con tolerancia " + str(tol))
  else:
    return("El método no converge")

f = x**3 + 2*x**2 - x -1 
df = sym.diff(f, x)
dff= sym.diff(df,x)
RaicesMultiples(f, df, dff, -3, 1000, 0.01)

"""Eliminación Gaussiana
Input (matriz A, vector fila b, tamaño n)

"""

import numpy as np
def eliminacionGaussiana(A, b):
  n = b.size
  Ab =  np.append(A,b, axis=1)
  for k in range(n):
    for i in range(k+1,n):
      mult = Ab[i][k] / Ab[k][k]
      for j in range(k,n+1):
        Ab[i][j]=Ab[i][j]-mult*Ab[k][j]
  x = np.zeros(n)
  x[n-1]=Ab[n-1][n]/Ab[n-1][n-1]
  for i in range(n-1,-1,-1):
    sum= 0 
    for p in range(i+1,n):
      sum = sum + Ab[i][p] * x[p]
    x[i] = (Ab[i][n]-sum)/Ab[i][i]
  return x


A = np.array([[2,-1,-3,2],[5,-10,2,-6],[5,-9,15,-6],[2,1,-1,10]],dtype='f')
b = np.array([[4],[3],[2],[1]])

A = np.array([[1, 1, 1],[4,2,1],[20.25,4.5,1]])
b = np.array([[2.5],[5],[6.7]])

A = np.array([[5,-1],[2,3]])
b= np.array([[4],[5]])
A = np.array([[1, 1, 1],[4,2,1],[20.25,4.5,1]])
b = np.array([[2.5],[5],[6.7]])

A = np.array([[2,-1,-3,2],[5,-10,2,-6],[5,-9,15,-6],[2,1,-1,10]],dtype='f')
b = np.array([[4],[3],[2],[1]])

print("El vector x resultante será: ")
print(eliminacionGaussiana(A,b))

"""Pivoteo parcial"""

import numpy as np
def pivoteoParcial(A, b):
  n = b.size
  Ab =  np.append(A,b, axis=1)
  for k in range(n):
    c = max(abs(Ab[k:,k]))
    index = list(abs(Ab[:,k])).index(c)
    maxx = np.array(Ab[index,:],dtype=float)
    Ab[index,:] = np.array(Ab[k,:],dtype=float)
    Ab[k,:] = maxx
    Ab = np.array(Ab,dtype=float)
    for i in range(k+1,n):
      mult = Ab[i][k] / Ab[k][k]
      for j in range(k,n+1):
        Ab[i][j]=Ab[i][j]-mult*Ab[k][j]
  x = np.zeros(n)
  x[n-1]=Ab[n-1][n]/Ab[n-1][n-1]
  for i in range(n-1,-1,-1):
    sum= 0 
    for p in range(i+1,n):
      sum = sum + Ab[i][p] * x[p]
    x[i] = (Ab[i][n]-sum)/Ab[i][i]
  return x


A = np.array([[-7, 2, -3, 4],[5,-1,14,-1],[1,9,-7,5],[-12,13,-8,-4]])
b = np.array([[-12],[13],[31],[-32]])


print("El vector x resultante será: ")
print(pivoteoParcial(A,b))

"""Pivoteo total"""

import numpy as np

def pivoteoTotal(A, b):
  n = b.size
  Ab =  np.append(A,b, axis=1)
  Ab = np.array(Ab,dtype=float)
  x = np.array(list(range(n)))
  for k in range(0,n):
    A = Ab[:,:-1]
    c = abs(A[k:,k:]).max()
    index = np.where(abs(A)==c)

    c_temp = Ab[:,index[1][0]].copy()
    Ab[:,index[1][0]]= Ab[:,k].copy()
    Ab[:,k] = c_temp

    x_temp= x[index[1][0]]
    x[index[1][0]]= x[k]
    x[k]= x_temp

    r_temp= Ab[index[0][0],:].copy()
    Ab[index[0][0],:]= Ab[k,:].copy()
    Ab[k,:] = r_temp

    Ab[k,:]= Ab[k,:]*(1/c)

    for i in range(0,n):
      if i != k:
        Ab[i,:]= Ab[i,:].copy()+Ab[k,:].copy()*(-Ab[i,k].copy())

  S= Ab[:,-1]
  B= []
  for i in range(0,n):
    B.append(S[np.where(x==i)])
  return B

A = np.array([[-7, 2, -3, 4],[5,-1,14,-1],[1,9,-7,5],[-12,13,-8,-4]])
b = np.array([[-12],[13],[31],[-32]])

pivoteoTotal(A,b)

"""Factorización LU"""

import numpy as np
def factorizacionLU(A):
    n, m = A.shape
    P = np.identity(n)
    L = np.identity(n)
    U = A.copy()
    PF = np.identity(n)
    LF = np.zeros((n,n))
    for k in range(0, n - 1):
        index = np.argmax(abs(U[k:,k]))
        index = index + k 
        if index != k:
            P = np.identity(n)
            P[[index,k],k:n] = P[[k,index],k:n]
            U[[index,k],k:n] = U[[k,index],k:n] 
            PF = np.dot(P,PF)
            LF = np.dot(P,LF)
        L = np.identity(n)
        for j in range(k+1,n):
            L[j,k] = -(U[j,k] / U[k,k])
            LF[j,k] = (U[j,k] / U[k,k])
        U = np.dot(L,U)
    np.fill_diagonal(LF, 1)
    return  LF, U


A = np.array([[3,-1,1],[1,-8,-2],[1,1,5]])
L,U=factorizacionLU(A)
print(L)
print(U)

"""Jacobi"""

from numpy.linalg import inv
def jacobi(A,b,tol,numIter):
  n = np.size(A,0)
  L = - np.tril(A, -1)
  U = - np.triu(A,1)
  D = A+L+U
  x0 = np.zeros([n,1])
  Tj = np.matmul(inv(D),(L+U))
  autovalores, autovectores = np.linalg.eig(Tj)
  autovalores = abs(autovalores)

  for lam in autovalores:
    if lam >= 1:
      return ("El método no converge.")

  C = np.matmul(inv(D),b)
  xn = (np.matmul(Tj,x0))+C
  error = np.array(abs(xn - (np.dot(Tj,xn)+C)))
  error = np.amax(error)
  iter = 0
  while ((error > tol) and (iter<numIter)):
    nuevo = np.matmul(Tj,xn)+C
    error = np.array(abs(nuevo-xn))
    error = np.amax(error)
    xn = nuevo
    iter = iter +1
  return("El método converge en "+str(xn))


A = np.array([[3,-1,1],[1,-8,-2],[1,1,5]])
b = np.array([[-2],[1],[4]])
tol = 10^(-5)
jacobi(A,b,tol,20)

"""Gauss-Seidel"""

from numpy.linalg import inv
def GaussSeidel(A,b,tol,numIter):
  n = np.size(A,0)
  L = - np.tril(A, -1)
  U = - np.triu(A,1)
  D = A+L+U
  x0 = np.zeros([n,1])
  Tg = np.matmul(inv(D-L),U)
  autovalores, autovectores = np.linalg.eig(Tg)
  autovalores = abs(autovalores)

  for lam in autovalores:
    if lam >= 1:
      return ("El método no converge.")

  C = np.matmul(inv(D-L),b)
  xn = (np.matmul(Tg,x0))+C
  error = np.array(abs(xn - (np.dot(Tg,xn)+C)))
  error = np.amax(error)
  iter = 0
  while ((error > tol) and (iter<numIter)):
    nuevo = np.matmul(Tg,xn)+C
    error = np.array(abs(nuevo-xn))
    error = np.amax(error)
    xn = nuevo
    iter = iter +1
  return("El método converge en "+str(xn))


A = np.array([[3,-1,1],[1,-8,-2],[1,1,5]])
b = np.array([[-2],[1],[4]])
tol = 10^(-5)
GaussSeidel(A,b,tol,20)

"""Diferencias divididas

"""

import numpy as np
import sympy as sym

x = sym.Symbol("x")
def diferenciasDivididas (puntos):
  n = np.size(puntos,0)
  X = puntos[:,0]
  Y = puntos[:,1]
  p = 0
  tabla = np.zeros([n, n])
  tabla[:,0] = Y
  for j in range(1,n):
    for i in range(n-j):
      tabla[i][j] = (tabla[i+1][j-1] - tabla[i][j-1]) / (X[i+j]-X[i])
  b = np.array(tabla[0,:])
  mult = 1
  for i in range(n):
    mult =1
    for j in range(i):
      mult = mult * (x-X[j])
    p = p + b[i]*(mult)
  p = sym.simplify(sym.expand(p))
  return p

puntos = np.array([[-2,12.135],[-1,6.368],[0,1],[1,-3.2817]])

diferenciasDivididas(puntos)

p = 12.13 + (-5.76)*(x+2)+(0.19)*(x+2)*(x+1)+(0.11)*(x+2)*(x+1)*x
p = sym.simplify(sym.expand(p))
p

"""Interpolación Lagrange"""

import sympy as sym
import numpy as np
x = sym.Symbol("x")
def lagrange(puntos):
  n = np.size(puntos,0)
  p = 0
  X = puntos[:,0]
  Y = puntos[:,1]
  for k in range(n):
    L=1
    for i in range(n):
      if i != k:
        L = L*((x-X[i])/(X[k]-X[i]))
    p = p +L*(Y[k])
  p = sym.simplify(sym.expand(p))
  return p

puntos = np.array([[-2,12.135],[-1,6.368],[2,-4.611],[3,2.086]])
lagrange(puntos)

"""Splines cuadráticas"""

import sympy as sym
import numpy as np
x = sym.Symbol("x")
def splinesCuadraticos(puntos):
  n = np.size(puntos,0)
  X = puntos[:,0]
  Y = puntos[:,1]
  y = [(Y[i//2]if i%2==0 else Y[(i)//2]) if i <= 2*(n-1) else 0 for i in range(1, 3*(n-1) + 1)]
  
  tabla = np.zeros([3*(n-1),3*(n-1)])

  for i in range(n-1):
    tabla[2*(i + 1) - 2][3*i] = tabla[2*(i + 1) - 1][3*i] = 1 
    tabla[2*(i + 1) - 2][3*i + 1] = X[i]
    tabla[2*(i + 1) - 2][3*i + 2] = X[i]**2
    tabla[2*(i + 1) - 1][3*i + 1] = X[i + 1]
    tabla[2*(i + 1) - 1][3*i + 2] = X[i + 1]**2

  for i in range(n-2):
    tabla[2*(n-1) + i][3*i + 1] = 1
    tabla[2*(n-1) + i][3*i + 4] = -1 
    tabla[2*(n-1) + i][3*i + 2] = 2*X[i + 1]
    tabla[2*(n-1) + i][3*i + 5] = -2*X[i + 1]

  tabla[3*(n-1) - 1][2] = 2

  tabla = np.linalg.inv(tabla)
  coef = np.matmul(tabla,y)
  p=[]
  cont = 0
  for j in range(n-1):
    pj = coef[cont] + coef[cont+1] * x + coef[cont+2]*x**2
    cont=cont+3
    p.append(pj)
  print(y)
  return p
puntos = np.array([[-2,12.135],[-1,6.368],[2,-4.611],[3,2.086]])
puntos = np.array([[-1, 0.038],[-0.8, 0.058],[-0.6, 0.1],[-0.4, 0.2]])
splinesCuadraticos(puntos)